@file:OptIn(kotlinx.cli.ExperimentalCli::class)

package org.example
/*
 * This source file was generated by the Gradle 'init' task
 */

import EntityError
import SalarySystem
import SalaryType
import kotlinx.cli.*
import java.time.LocalDate
import java.time.format.DateTimeParseException

class Context(
    val salarySystem: SalarySystem,
)

sealed class CliException(
    message: String,
) : Exception(message) {
    class InvalidArgument(
        message: String,
    ) : CliException(message)

    class InternalError(
        message: String,
    ) : CliException(message)
}

class AddEmp(
    private val ctx: Context,
) : Subcommand("AddEmp", "従業員を追加します") {
    val employeeId by option(ArgType.Int, shortName = "e", description = "従業員ID").required()

    // • 'name' hides member of supertype 'Subcommand' and needs 'override' modifier [VIRTUAL_MEMBER_HIDDEN]
    // so, use innerName instead of name
    val innerName by option(ArgType.String, fullName = "name", shortName = "n", description = "従業員名").required()
    val address by option(ArgType.String, shortName = "a", description = "従業員住所").required()
    val restArgs by argument(
        ArgType.String,
        description =
            """
            H <hourly>
            S <monthly>
            C <monthly-rate> <commission> 
            """.trimIndent(),
    ).vararg()

    override fun execute() {
        println(restArgs)
        val type = restArgs.getOrNull(0)
        val salaryInput: SalaryType =
            when (type) {
                "H" -> {
                    val hourly =
                        restArgs.getOrNull(1)?.toDoubleOrNull()
                            ?: throw CliException.InvalidArgument("H の場合は時給を数値で指定してください")
                    SalaryType.Hourly(hourly)
                }
                "S" -> {
                    val monthly =
                        restArgs.getOrNull(1)?.toDoubleOrNull()
                            ?: throw CliException.InvalidArgument("S の場合は月給を数値で指定してください")
                    SalaryType.Monthly(monthly)
                }
                "C" -> {
                    val monthly =
                        restArgs.getOrNull(1)?.toDoubleOrNull()
                            ?: throw CliException.InvalidArgument("C の場合は月給を数値で指定してください")
                    val commission =
                        restArgs.getOrNull(1)?.toDoubleOrNull()
                            ?: throw CliException.InvalidArgument("C の場合はコミッションを数値で指定してください")
                    SalaryType.Commission(monthly, commission)
                }
                else -> throw CliException.InvalidArgument("typeはH, S, Cのいずれかで指定してください")
            }

        ctx.salarySystem.addEmployee(employeeId, innerName, address, salaryInput)
    }
}

class DeleteEmp(
    private val ctx: Context,
) : Subcommand("DeleteEmp", "従業員を削除します") {
    val employeeId by option(ArgType.Int, shortName = "id", description = "従業員ID").required()

    override fun execute() {
        println("従業員を削除: ID=$employeeId")
        ctx.salarySystem.deleteEmployee(employeeId)
    }
}

class TimeCard(
    private val ctx: Context,
) : Subcommand("TimeCard", "タイムカード登録") {
    val employeeId by option(ArgType.Int, shortName = "id", description = "従業員ID").required()
    val date by option(ArgType.String, shortName = "d", description = "日付").required()
    val hours by option(ArgType.Int, shortName = "h", description = "時間").required()

    override fun execute() {
        println("タイムカード登録")
        ctx.salarySystem.addSalesReceipt(employeeId, parseDate(date), hours)
    }
}

class SalesReceipt(
    private val ctx: Context,
) : Subcommand("SalesReceipt", "売上伝票登録") {
    val employeeId by option(ArgType.Int, shortName = "id", description = "従業員ID").required()
    val date by option(ArgType.String, shortName = "d", description = "日付").required()
    val amount by option(ArgType.Int, shortName = "s", description = "売上金額").required()

    override fun execute() {
        println("売上伝票登録")
        ctx.salarySystem.addSalesReceipt(employeeId, parseDate(date), amount)
    }
}

class ServiceCharge(
    private val ctx: Context,
) : Subcommand("ServiceCharge", "サービス料金登録") {
    val memberId by option(ArgType.Int, shortName = "id", description = "従業員ID").required()
    val amount by option(ArgType.Int, shortName = "s", description = "料金額").required()

    override fun execute() {
        println("サービス料金登録")
        ctx.salarySystem.addServiceCharge(memberId, amount)
    }
}

class ChangeEmployee(
    private val ctx: Context,
) : Subcommand("ChangeEmployee", "従業員情報の変更") {
    val employeeId by option(ArgType.Int, shortName = "id", description = "従業員ID").required()
    val field by option(ArgType.String, shortName = "f", description = "変更フィールド").required()
    val value by option(ArgType.String, shortName = "v", description = "変更値").required()

    override fun execute() {
        println("従業員情報の変更")
        TODO()
        // ctx.salarySystem.changeEmployee(employeeId, field, value)
    }
}

class Payday(
    private val ctx: Context,
) : Subcommand("Payday", "給料日処理") {
    val date by option(ArgType.String, shortName = "d", description = "日付").required()

    override fun execute() {
        println("給料日処理")
        ctx.salarySystem.payday(parseDate(date))
    }
}

fun main(args: Array<String>) {
    val parser = ArgParser("cli-sample")
    val ctx = Context(SalarySystem())
    try {
        parser.subcommands(
            AddEmp(ctx),
            DeleteEmp(ctx),
            TimeCard(ctx),
            SalesReceipt(ctx),
            ServiceCharge(ctx),
            ChangeEmployee(ctx),
            Payday(ctx),
        )
        parser.parse(args)
    } catch (e: Exception) {
        print("CLIエラー: ${e.message}")
        when (e) {
            is CliException.InvalidArgument -> println("入力エラー: ${e.message}")
            is CliException.InternalError -> println("内部エラー: ${e.message}")
            is EntityError.UserError -> println("ユーザーエラー: ${e.message}")
        }
    }
}

fun parseDate(date: String): LocalDate =
    try {
        LocalDate.parse(date)
    } catch (e: DateTimeParseException) {
        println("日付の形式が正しくありません（例: 2024-06-16）")
        throw e
    }
