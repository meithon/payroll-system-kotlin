@file:OptIn(kotlinx.cli.ExperimentalCli::class)

package org.example
/*
 * This source file was generated by the Gradle 'init' task
 */

import ChangeEmployeeField
import EntityError
import SalarySystem
import SalaryType
import kotlinx.cli.*
import kotlinx.datetime.LocalDate
import java.time.format.DateTimeParseException

class Context(
    val salarySystem: SalarySystem,
)

sealed class CliException(
    message: String,
) : Exception(message) {
    class InvalidArgument(
        message: String,
    ) : CliException(message)

    class InternalError(
        message: String,
    ) : CliException(message)
}

class AddEmp(
    private val ctx: Context,
) : Subcommand("AddEmp", "従業員を追加します") {
    val employeeId by option(ArgType.Int, shortName = "e", description = "従業員ID").required()

    // • 'name' hides member of supertype 'Subcommand' and needs 'override' modifier [VIRTUAL_MEMBER_HIDDEN]
    // so, use innerName instead of name
    val innerName by option(ArgType.String, fullName = "name", shortName = "n", description = "従業員名").required()
    val address by option(ArgType.String, shortName = "a", description = "従業員住所").required()
    val restArgs by argument(
        ArgType.String,
        description =
            """
            H <hourly>
            S <monthly>
            C <monthly-rate> <commission> 
            """.trimIndent(),
    ).vararg()

    override fun execute() {
        println(restArgs)
        val type = restArgs.getOrNull(0)
        val salaryInput: SalaryType =
            when (type) {
                "H" -> {
                    val hourly =
                        restArgs.getOrNull(1)?.toDoubleOrNull()
                            ?: throw CliException.InvalidArgument("H の場合は時給を数値で指定してください")
                    SalaryType.Hourly(hourly)
                }
                "S" -> {
                    val monthly =
                        restArgs.getOrNull(1)?.toDoubleOrNull()
                            ?: throw CliException.InvalidArgument("S の場合は月給を数値で指定してください")
                    SalaryType.Monthly(monthly)
                }
                "C" -> {
                    val monthly =
                        restArgs.getOrNull(1)?.toDoubleOrNull()
                            ?: throw CliException.InvalidArgument("C の場合は月給を数値で指定してください")
                    val commission =
                        restArgs.getOrNull(1)?.toDoubleOrNull()
                            ?: throw CliException.InvalidArgument("C の場合はコミッションを数値で指定してください")
                    SalaryType.Commission(monthly, commission)
                }
                else -> throw CliException.InvalidArgument("typeはH, S, Cのいずれかで指定してください")
            }

        ctx.salarySystem.addEmployee(employeeId, innerName, address, salaryInput)
    }
}

class DeleteEmp(
    private val ctx: Context,
) : Subcommand("DeleteEmp", "従業員を削除します") {
    val employeeId by option(ArgType.Int, shortName = "id", description = "従業員ID").required()

    override fun execute() {
        println("従業員を削除: ID=$employeeId")
        ctx.salarySystem.deleteEmployee(employeeId)
    }
}

class TimeCard(
    private val ctx: Context,
) : Subcommand("TimeCard", "タイムカード登録") {
    val employeeId by option(ArgType.Int, shortName = "id", description = "従業員ID").required()
    val date by option(ArgType.String, shortName = "d", description = "日付").required()
    val hours by option(ArgType.Double, shortName = "h", description = "時間").required()

    override fun execute() {
        println("タイムカード登録")
        ctx.salarySystem.addSalesReceipt(employeeId, parseDate(date), hours)
    }
}

class SalesReceipt(
    private val ctx: Context,
) : Subcommand("SalesReceipt", "売上伝票登録") {
    val employeeId by option(ArgType.Int, shortName = "id", description = "従業員ID").required()
    val date by option(ArgType.String, shortName = "d", description = "日付").required()
    val amount by option(ArgType.Double, shortName = "s", description = "売上金額").required()

    override fun execute() {
        println("売上伝票登録")
        ctx.salarySystem.addSalesReceipt(employeeId, parseDate(date), amount)
    }
}

class ServiceCharge(
    private val ctx: Context,
) : Subcommand("ServiceCharge", "サービス料金登録") {
    val memberId by option(ArgType.Int, shortName = "id", description = "従業員ID").required()
    val amount by option(ArgType.Double, shortName = "s", description = "料金額").required()

    override fun execute() {
        println("サービス料金登録")
        ctx.salarySystem.addServiceCharge(memberId, amount)
    }
}

class ChangeEmployee(
    private val ctx: Context,
) : Subcommand("ChangeEmployee", "従業員情報の変更") {
    val employeeId by option(ArgType.Int, shortName = "id", description = "従業員ID").required()
    val restArgs by argument(
        ArgType.String,
        description =
            """
            Name         <name>                 従業員名
            Address      <address>              住所
            Hourly       <HourlyRate>           時間給
            Salaried     <salary>               固定給
            Commissioned <salary> <rate>        手当
            PayMethod    <payMethod>            支払い形態
            Hold                                給与担当者が小切手を渡すまで待つ
            Direct       <bank> <account>       直接振り込み
            Mail         <mail>                 小切手を郵送
            Member       <memberId> Dues <rate> 組合員情報を変更する
            NoMember                            組合員から外す
            """.trimIndent(),
    ).vararg()

    override fun execute() {
        var changeEmployeeField: ChangeEmployeeField =
            when (restArgs[0].lowercase()) {
                "name" -> {
                    val value =
                        restArgs.getOrNull(1)
                            ?: throw CliException.InvalidArgument("nameを指定してください")
                    ChangeEmployeeField.Name(value)
                }
                "address" -> {
                    val value =
                        restArgs.getOrNull(1)
                            ?: throw CliException.InvalidArgument("addressを指定してください")
                    ChangeEmployeeField.Address(value)
                }
                "salaried" -> {
                    val value =
                        restArgs.getOrNull(1)?.toDoubleOrNull()
                            ?: throw CliException.InvalidArgument("salary（金額）を指定してください")
                    ChangeEmployeeField.Salaried(value)
                }
                "commissioned" -> {
                    val vals = restArgs.drop(1)
                    if (vals.size < 2) throw CliException.InvalidArgument("salary, commissionRateの2つを指定してください")
                    ChangeEmployeeField.Commissioned(
                        vals[0].toDoubleOrNull() ?: throw CliException.InvalidArgument("salaryの数値変換に失敗"),
                        vals[1].toDoubleOrNull() ?: throw CliException.InvalidArgument("commissionRateの数値変換に失敗"),
                    )
                }
                "paymethod" -> {
                    val value =
                        restArgs.getOrNull(1)
                            ?: throw CliException.InvalidArgument("payMethodを指定してください")
                    ChangeEmployeeField.PayMethod(PayMethodType.valueOf(value.uppercase()))
                }
                "hourly" -> {
                    val value =
                        restArgs.getOrNull(1)?.toDoubleOrNull()
                            ?: throw CliException.InvalidArgument("hourlyRate（金額）を指定してください")
                    ChangeEmployeeField.Hourly(value)
                }
                "hold" -> ChangeEmployeeField.Hold
                "direct" -> {
                    val vals = restArgs.drop(1)
                    if (vals.size < 2) throw CliException.InvalidArgument("bank, accountの2つを指定してください")
                    ChangeEmployeeField.Direct(
                        vals[0],
                        vals[1],
                    )
                }
                "mail" -> {
                    val value =
                        restArgs.getOrNull(1)
                            ?: throw CliException.InvalidArgument("mailアドレスを指定してください")
                    ChangeEmployeeField.Mail(value)
                }
                "member" -> {
                    val vals = restArgs.drop(1)
                    if (vals.size < 2) throw CliException.InvalidArgument("memberId, duesの2つを指定してください")
                    ChangeEmployeeField.Member(
                        vals[0].toIntOrNull() ?: throw CliException.InvalidArgument("memberIdは整数にしてください"),
                        vals[1].toDoubleOrNull() ?: throw CliException.InvalidArgument("duesは数値にしてください"),
                    )
                }
                "nomember" -> ChangeEmployeeField.NoMember
                else -> throw CliException.InvalidArgument("Invalid field: ${restArgs[0]}")
            }
        println("従業員情報の変更")
        ctx.salarySystem.changeEmployee(employeeId, changeEmployeeField)
    }
}

class Payday(
    private val ctx: Context,
) : Subcommand("Payday", "給料日処理") {
    val date by option(ArgType.String, shortName = "d", description = "日付").required()

    override fun execute() {
        println("給料日処理")
        ctx.salarySystem.payday(parseDate(date))
    }
}

fun main(args: Array<String>) {
    val parser = ArgParser("cli-sample")
    val ctx = Context(SalarySystem())
    try {
        parser.subcommands(
            AddEmp(ctx),
            DeleteEmp(ctx),
            TimeCard(ctx),
            SalesReceipt(ctx),
            ServiceCharge(ctx),
            ChangeEmployee(ctx),
            Payday(ctx),
        )
        parser.parse(args)
    } catch (e: Exception) {
        print("CLIエラー: ${e.message}")
        when (e) {
            is CliException.InvalidArgument -> println("入力エラー: ${e.message}")
            is CliException.InternalError -> println("内部エラー: ${e.message}")
            is EntityError.UserError -> println("ユーザーエラー: ${e.message}")
        }
    }
}

fun parseDate(date: String): LocalDate =
    try {
        LocalDate.parse(date)
    } catch (e: DateTimeParseException) {
        println("日付の形式が正しくありません（例: 2024-06-16）")
        throw e
    }
